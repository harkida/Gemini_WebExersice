<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ­ Roleplay â€” Conversazione</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', sans-serif;
            background: #1a1b1e;
            color: #e0e0e0;
            height: 100dvh;
            display: flex;
            flex-direction: column;
        }

        /* â”€â”€ í—¤ë” â”€â”€ */
        .header {
            background: #2b2d31;
            padding: 12px 20px;
            border-bottom: 1px solid #3a3c41;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .header-left { display: flex; align-items: center; gap: 12px; }
        .header-left h1 { font-size: 1.1em; color: #f0a500; }
        .header-left .team-badge {
            background: #f0a50020;
            color: #f0a500;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: 600;
        }
        .header-right { display: flex; align-items: center; gap: 12px; }
        .turn-counter {
            background: #7289da20;
            color: #7289da;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 600;
        }
        .btn-exit {
            background: none;
            border: 1px solid #555;
            color: #999;
            padding: 5px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8em;
        }
        .btn-exit:hover { border-color: #999; color: #fff; }

        /* â”€â”€ ì‹œë‚˜ë¦¬ì˜¤ ë°” â”€â”€ */
        .scenario-bar {
            background: #2b2d31;
            padding: 10px 20px;
            border-bottom: 1px solid #3a3c41;
            display: flex;
            align-items: center;
            gap: 16px;
            font-size: 0.85em;
        }
        .scenario-bar .npc-name { color: #f0a500; font-weight: 700; }
        .scenario-bar .situation { color: #999; }

        /* â”€â”€ ì±„íŒ… ì˜ì—­ â”€â”€ */
        .chat-area {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .msg {
            max-width: 75%;
            padding: 12px 16px;
            border-radius: 16px;
            line-height: 1.5;
            font-size: 0.95em;
            position: relative;
        }
        .msg.player {
            align-self: flex-end;
            background: #7289da;
            color: #fff;
            border-bottom-right-radius: 4px;
        }
        .msg.npc {
            align-self: flex-start;
            background: #2b2d31;
            border: 1px solid #3a3c41;
            border-bottom-left-radius: 4px;
        }
        .msg.system {
            align-self: center;
            background: #f0a50015;
            border: 1px solid #f0a50030;
            color: #f0a500;
            font-size: 0.85em;
            max-width: 90%;
            text-align: center;
            border-radius: 8px;
        }
        .msg .label {
            font-size: 0.7em;
            font-weight: 600;
            margin-bottom: 4px;
            opacity: 0.7;
        }
        .msg .meta {
            font-size: 0.7em;
            opacity: 0.5;
            margin-top: 4px;
            text-align: right;
        }

        /* NPC ì˜¤ë””ì˜¤ ë²„íŠ¼ */
        .npc-audio-btn {
            display: inline-block;
            background: #f0a50030;
            border: none;
            color: #f0a500;
            padding: 4px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
            margin-top: 6px;
        }
        .npc-audio-btn:hover { background: #f0a50050; }

        /* NPC í…ìŠ¤íŠ¸ í† ê¸€ */
        .npc-text-hidden {
            display: none;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255,255,255,0.1);
            font-size: 0.9em;
            color: #ccc;
        }
        .npc-text-hidden.visible { display: block; }

        /* â”€â”€ ë¡œë”© â”€â”€ */
        .loading-bar {
            display: none;
            padding: 12px 20px;
            background: #2b2d31;
            border-top: 1px solid #3a3c41;
            text-align: center;
            color: #f0a500;
            font-size: 0.9em;
        }
        .loading-bar.active { display: block; }
        .spinner {
            display: inline-block;
            width: 16px; height: 16px;
            border: 2px solid #f0a50040;
            border-top-color: #f0a500;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            vertical-align: middle;
            margin-right: 8px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* â”€â”€ ì…ë ¥ ì˜ì—­ â”€â”€ */
        .input-area {
            background: #2b2d31;
            padding: 14px 20px;
            border-top: 1px solid #3a3c41;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .input-area input {
            flex: 1;
            background: #1a1b1e;
            border: 1px solid #3a3c41;
            color: #e0e0e0;
            padding: 10px 14px;
            border-radius: 8px;
            font-size: 0.95em;
            font-family: inherit;
        }
        .input-area input:focus { outline: none; border-color: #7289da; }

        .btn-record {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 10px 18px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            font-size: 0.95em;
            transition: background 0.2s;
            white-space: nowrap;
        }
        .btn-record:hover { background: #c0392b; }
        .btn-record.recording {
            background: #27ae60;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.6; } }

        .btn-send {
            background: #7289da;
            color: white;
            border: none;
            padding: 10px 18px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            font-size: 0.95em;
            white-space: nowrap;
        }
        .btn-send:hover { background: #5b6eae; }
        .btn-send:disabled { background: #555; cursor: not-allowed; }

        .btn-listen {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 14px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95em;
        }
        .btn-listen:hover { background: #2980b9; }

        /* â”€â”€ ì‹œë‚˜ë¦¬ì˜¤ ì™„ë£Œ ì˜¤ë²„ë ˆì´ â”€â”€ */
        .overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.8);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }
        .overlay.active { display: flex; }
        .overlay-box {
            background: #2b2d31;
            border: 1px solid #f0a50040;
            border-radius: 16px;
            padding: 40px;
            text-align: center;
            max-width: 400px;
        }
        .overlay-box h2 { color: #f0a500; margin-bottom: 12px; }
        .overlay-box p { color: #999; margin-bottom: 24px; }
        .overlay-box .btn-primary {
            background: #f0a500;
            color: #000;
            border: none;
            padding: 10px 24px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            font-size: 1em;
        }
        .overlay-box .btn-primary:hover { background: #d99400; }

        /* â”€â”€ typing indicator â”€â”€ */
        .typing-bubble {
            align-self: flex-start;
            background: #2b2d31;
            border: 1px solid #3a3c41;
            border-radius: 16px;
            border-bottom-left-radius: 4px;
            padding: 14px 20px;
            display: flex;
            gap: 5px;
            align-items: center;
        }
        .typing-bubble .dot {
            width: 8px;
            height: 8px;
            background: #f0a500;
            border-radius: 50%;
            animation: typingDot 1.4s infinite;
        }
        .typing-bubble .dot:nth-child(2) { animation-delay: 0.2s; }
        .typing-bubble .dot:nth-child(3) { animation-delay: 0.4s; }
        @keyframes typingDot {
            0%, 60%, 100% { opacity: 0.3; transform: scale(0.8); }
            30% { opacity: 1; transform: scale(1); }
        }

        /* â”€â”€ ëª¨ë°”ì¼ ë°˜ì‘í˜• â”€â”€ */
        @media (max-width: 480px) {
            .header { padding: 8px 12px; }
            .header-left h1 { font-size: 0.9em; }
            .header-left .team-badge { font-size: 0.7em; padding: 2px 8px; }
            .header-right { gap: 6px; }
            .turn-counter { font-size: 0.7em; padding: 3px 8px; }
            .btn-exit { font-size: 0.7em; padding: 4px 10px; }
            .scenario-bar { padding: 8px 12px; font-size: 0.8em; }
            .msg { max-width: 85%; font-size: 0.9em; }
            .input-area { padding: 10px 12px; gap: 6px; }
            .btn-record { padding: 8px 12px; font-size: 0.85em; }
            .btn-send { padding: 8px 12px; font-size: 0.85em; }
            .input-area input { padding: 8px 10px; font-size: 0.85em; }
        }


    </style>
</head>
<body>

<!-- í—¤ë” -->
<div class="header">
    <div class="header-left">
        <h1>ğŸ­ Roleplay</h1>
        <span class="team-badge" id="teamBadge">Team -</span>
    </div>
    <div class="header-right">
        <span class="turn-counter" id="turnCounter">Turno: 0/8</span>
        <button class="btn-exit" onclick="exitPlay()">â† Esci</button>
    </div>
</div>

<!-- ì‹œë‚˜ë¦¬ì˜¤ ë°” -->
<div class="scenario-bar">
    <span>ğŸ—£ï¸ <span class="npc-name" id="npcName">-</span></span>
    <span class="situation" id="situationText">Caricamento...</span>
</div>

<!-- ì±„íŒ… -->
<div class="chat-area" id="chatArea">
    <div class="msg system">
        ğŸ’¡ La sessione Ã¨ iniziata! Parla in coreano con l'NPC.<br>
        <small>Premi il pulsante ğŸ¤ per registrare, oppure scrivi in basso.</small>
    </div>
</div>

<!-- ì…ë ¥ -->
<div class="input-area">
    <button class="btn-record" id="btnRecord" onclick="toggleRecording()">ğŸ¤ Registra</button>
    <button class="btn-listen" id="btnListen" onclick="playRecording()" style="display:none;">ğŸ”Š</button>
    <button class="btn-send" id="btnSendAudio" onclick="sendAudio()" style="display:none;">ğŸ“¤ Invia audio</button>
    <input type="text" id="textInput" placeholder="Scrivi in coreano (debug)..." />
    <button class="btn-send" id="btnSendText" onclick="sendText()">Invia</button>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â• ìƒíƒœ â•â•â•â•â•â•â•â•â•â•â•
const urlParams = new URLSearchParams(window.location.search);
const sessionId = urlParams.get('session_id');
let teamId = null;
let currentScenarioId = null;
let currentScenario = null;
let turnsRemaining = 8;
let isProcessing = false;

// â•â•â•â•â•â•â•â•â•â•â• ë…¹ìŒ â•â•â•â•â•â•â•â•â•â•â•
let mediaRecorder = null;
let audioChunks = [];
let recordedBlob = null;
let recordedMimeType = 'audio/mp4';

// â•â•â•â•â•â•â•â•â•â•â• NPC ì˜¤ë””ì˜¤ ì €ì¥ì†Œ â•â•â•â•â•â•â•â•â•â•â•
const audioStore = {};
let audioCounter = 0;

// â˜… ì¶”ê°€: ë™ê¸°í™” í´ë§
let syncInterval = null;
let lastKnownTurn = 0;
let lastKnownLogCount = 0;
let allScenarios = [];

// â•â•â•â•â•â•â•â•â•â•â• ì´ˆê¸°í™” â•â•â•â•â•â•â•â•â•â•â•
document.addEventListener('DOMContentLoaded', async () => {
    if (!sessionId) {
        alert('Errore: session_id mancante.');
        window.location.href = '/student-dashboard';
        return;
    }
    await loadSessionInfo();
});

// Enterë¡œ í…ìŠ¤íŠ¸ ì „ì†¡
document.getElementById('textInput').addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendText();
    }
});

// â•â•â•â•â•â•â•â•â•â•â• íŒ€ ë™ê¸°í™” í´ë§ â•â•â•â•â•â•â•â•â•â•â•
function startSyncPolling() {
    stopSyncPolling();
    syncInterval = setInterval(syncFromServer, 3000);
}

function stopSyncPolling() {
    if (syncInterval) { clearInterval(syncInterval); syncInterval = null; }
}

// íƒ­ ë¹„í™œì„± ì‹œ í´ë§ ì¤‘ì§€, í™œì„± ì‹œ ì¬ê°œ
document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        stopSyncPolling();
    } else if (!isProcessing && turnsRemaining > 0) {
        startSyncPolling();
    }
});

async function syncFromServer() {
    if (!currentScenarioId || isProcessing) return;

    try {
        const res = await fetch(
            `/api/rp-play/history?session_id=${sessionId}&scenario_id=${currentScenarioId}`
        );
        const data = await res.json();
        if (!data.logs) return;

        // ë¡œê·¸ ê°œìˆ˜ë¡œ ìƒˆ ë©”ì‹œì§€ íŒë‹¨
        if (data.logs.length > lastKnownLogCount) {
            // ìƒˆë¡œ ì¶”ê°€ëœ ë¡œê·¸ë§Œ ì²˜ë¦¬
            const newLogs = data.logs.slice(lastKnownLogCount);
            for (const log of newLogs) {
                if (log.speaker === 'player') {
                    const text = log.message_text || '';
                    addMessage('player', text ? `ğŸ¤ "${text}"` : 'ğŸ¤ (Audio)');
                } else if (log.speaker === 'npc') {
                    const npcText = log.actor_line || log.message_text || '';
                    const audioUrl = log.pre_audio_url || null;
                    const ttsB64 = log.tts_audio_base64 || null;
                    addNpcMessage(npcText, audioUrl, ttsB64, log.turn_number);
                }
            }

            // Exit DYN ë™ê¸°í™” ì²´í¬
            const exitLog = newLogs.find(log => log.speaker === 'npc' && log.message_text === '[EXIT]');
            if (exitLog) {
                lastKnownLogCount = data.logs.length;
                const npcName = document.getElementById('npcName').textContent;
                addMessage('system', `ğŸšª ${npcName} ha lasciato la conversazione.`);
                stopSyncPolling();
                document.querySelector('.input-area').style.display = 'none';
                showExitOptions();
                return;
            }

            // Goal Achievement ë™ê¸°í™” ì²´í¬
            const goalLog = newLogs.find(log => log.speaker === 'npc' && log.message_text === '[GOAL_ACHIEVED]');
            if (goalLog) {
                lastKnownLogCount = data.logs.length;
                fetch(`/api/rp/evaluate?team_id=${teamId}&scenario_id=${currentScenarioId}`, { method: 'POST' });
                showGoalAchieved();
                return;
            }

            lastKnownLogCount = data.logs.length;
            lastKnownTurn = data.current_turn;
            turnsRemaining = data.turns_remaining;
            updateTurnCounter(data.current_turn, 8);

            if (turnsRemaining <= 0) {
                const lastLog = data.logs[data.logs.length - 1];
                if (lastLog && lastLog.speaker === 'npc') {
                    showComplete();
                    stopSyncPolling();
                }
            }
        }
    } catch (e) {
        console.error('ë™ê¸°í™” ì‹¤íŒ¨:', e);
    }
}

// â•â•â•â•â•â•â•â•â•â•â• ì„¸ì…˜ ì •ë³´ ë¡œë“œ â•â•â•â•â•â•â•â•â•â•â•
async function loadSessionInfo() {
    try {
        const res = await fetch(`/api/rp-play/session-info?session_id=${sessionId}`);
        const data = await res.json();

        if (data.error) {
            alert(`Errore: ${data.error}`);
            window.location.href = '/roleplay-lobby';
            return;
        }

        teamId = data.team_id;
        document.getElementById('teamBadge').textContent = `Team ${data.team_code}`;

        // ì²« ë²ˆì§¸ ì‹œë‚˜ë¦¬ì˜¤ ë¡œë“œ
        allScenarios = data.scenarios || [];
        if (allScenarios.length > 0) {
            const sc = allScenarios[0];
            currentScenarioId = sc.scenario_id;
            turnsRemaining = data.max_turns - sc.current_turn;
            updateTurnCounter(sc.current_turn, data.max_turns);
            applyScenarioDetail(sc);

            // ì´ë¯¸ ì§„í–‰ ì¤‘ì¸ ëŒ€í™”ê°€ ìˆìœ¼ë©´ ê¸°ë¡ ë¡œë“œ
            if (sc.current_turn > 0) {
                await loadHistory();
            }
        }

        // â˜… ì¶”ê°€
        startSyncPolling();

    } catch (e) {
        console.error('ì„¸ì…˜ ë¡œë“œ ì‹¤íŒ¨:', e);
        alert('Errore nel caricamento della sessione.');
    }
}

// â•â•â•â•â•â•â•â•â•â•â• ì‹œë‚˜ë¦¬ì˜¤ ìƒì„¸ ë¡œë“œ (NPC ì´ë¦„, ìƒí™© í‘œì‹œ) â•â•â•â•â•â•â•â•â•â•â•
function applyScenarioDetail(sc) {
    if (sc) {
        currentScenario = sc;
        document.getElementById('npcName').textContent = sc.npc_name || 'NPC';
        document.getElementById('situationText').textContent = sc.title || '';
    }
}

// â•â•â•â•â•â•â•â•â•â•â• ê¸°ì¡´ ëŒ€í™” ê¸°ë¡ ë¡œë“œ â•â•â•â•â•â•â•â•â•â•â•
async function loadHistory() {
    try {
        const res = await fetch(
            `/api/rp-play/history?session_id=${sessionId}&scenario_id=${currentScenarioId}`
        );
        const data = await res.json();
        if (!data.logs) return;

        for (const log of data.logs) {
            if (log.speaker === 'player') {
                const text = log.message_text || '';
                addMessage('player', text ? `ğŸ¤ "${text}"` : 'ğŸ¤ (Audio)');
            } else if (log.speaker === 'npc') {
                const npcText = log.actor_line || log.message_text || '';
                const audioUrl = log.pre_audio_url || null;
                const ttsB64 = log.tts_audio_base64 || null;
                addNpcMessage(npcText, audioUrl, ttsB64, log.turn_number);
            }
        }

        turnsRemaining = data.turns_remaining;
        updateTurnCounter(data.current_turn, 8);
        lastKnownTurn = data.current_turn;  // â˜… ì¶”ê°€
        lastKnownLogCount = data.logs.length;

        // ì´ë¯¸ ëª©ì  ë‹¬ì„±ëœ ì‹œë‚˜ë¦¬ì˜¤ì¸ì§€ í™•ì¸
        const goalLog = data.logs.find(log => log.speaker === 'npc' && log.message_text === '[GOAL_ACHIEVED]');
        if (goalLog) {
            showGoalAchieved();
            return;
        }
    } catch (e) {
        console.error('ê¸°ë¡ ë¡œë“œ ì‹¤íŒ¨:', e);
    }
}

// â•â•â•â•â•â•â•â•â•â•â• í„´ ì¹´ìš´í„° ì—…ë°ì´íŠ¸ â•â•â•â•â•â•â•â•â•â•â•
function updateTurnCounter(current, max) {
    document.getElementById('turnCounter').textContent = `Turno: ${current}/${max}`;
}

// â•â•â•â•â•â•â•â•â•â•â• í…ìŠ¤íŠ¸ ì „ì†¡ â•â•â•â•â•â•â•â•â•â•â•
async function sendText() {
    const input = document.getElementById('textInput');
    const text = input.value.trim();
    if (!text || isProcessing) return;

    input.value = '';
    await processPlayerInput({ type: 'text', text });
}

// â•â•â•â•â•â•â•â•â•â•â• ë…¹ìŒ ì»¨íŠ¸ë¡¤ â•â•â•â•â•â•â•â•â•â•â•
async function toggleRecording() {
    const btn = document.getElementById('btnRecord');

    if (mediaRecorder && mediaRecorder.state === 'recording') {
        // ë…¹ìŒ ì¤‘ì§€
        mediaRecorder.stop();
        mediaRecorder.stream.getTracks().forEach(t => t.stop());
        return;
    }

    try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

        if (MediaRecorder.isTypeSupported('audio/mp4')) {
            recordedMimeType = 'audio/mp4';
        } else if (MediaRecorder.isTypeSupported('audio/webm')) {
            recordedMimeType = 'audio/webm';
        } else {
            recordedMimeType = '';
        }

        const options = recordedMimeType ? { mimeType: recordedMimeType } : {};
        mediaRecorder = new MediaRecorder(stream, options);
        audioChunks = [];

        mediaRecorder.ondataavailable = (e) => {
            if (e.data.size > 0) audioChunks.push(e.data);
        };

        mediaRecorder.onstop = () => {
            recordedBlob = new Blob(audioChunks, { type: recordedMimeType || 'audio/mp4' });
            btn.textContent = 'ğŸ¤ Registra';
            btn.classList.remove('recording');
            document.getElementById('btnListen').style.display = 'inline-block';
            document.getElementById('btnSendAudio').style.display = 'inline-block';
            document.getElementById('textInput').style.display = 'none';
            document.getElementById('btnSendText').style.display = 'none';
        };

        mediaRecorder.start();
        btn.textContent = 'â¹ Stop';
        btn.classList.add('recording');
        document.getElementById('btnListen').style.display = 'none';
        document.getElementById('btnSendAudio').style.display = 'none';
        recordedBlob = null;
    } catch (e) {
        alert('Errore microfono: ' + e.message);
    }
}

function playRecording() {
    if (!recordedBlob) return;
    const url = URL.createObjectURL(recordedBlob);
    new Audio(url).play();
}

async function sendAudio() {
    if (!recordedBlob || isProcessing) return;

    // ë…¹ìŒ ë²„íŠ¼ ë¦¬ì…‹
    document.getElementById('btnListen').style.display = 'none';
    document.getElementById('btnSendAudio').style.display = 'none';
    document.getElementById('textInput').style.display = '';
    document.getElementById('btnSendText').style.display = '';

    await processPlayerInput({ type: 'audio', blob: recordedBlob, mimeType: recordedMimeType });
    recordedBlob = null;
}

// â•â•â•â•â•â•â•â•â•â•â• í•µì‹¬: í”Œë ˆì´ì–´ ì…ë ¥ ì²˜ë¦¬ â•â•â•â•â•â•â•â•â•â•â•
async function processPlayerInput(input) {
    if (isProcessing) return;
    isProcessing = true;
    setInputEnabled(false);
    
    try {
        let res;

        if (input.type === 'text') {
            addMessage('player', input.text);
            showLoading(true);
            res = await fetch('/api/rp-play/send-text', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    session_id: sessionId,
                    scenario_id: currentScenarioId,
                    student_input: input.text
                })
            });
        } else {
            addMessage('player', 'ğŸ¤ (Audio inviato)');
            showLoading(true);

            const ext = input.mimeType.includes('webm') ? 'webm' : 'mp4';
            const formData = new FormData();
            formData.append('session_id', sessionId);
            formData.append('scenario_id', currentScenarioId);
            formData.append('audio_file', input.blob, `recording.${ext}`);
            formData.append('mime_type', input.mimeType);

            res = await fetch('/api/rp-play/send-audio', {
                method: 'POST',
                body: formData
            });
        }

        const data = await res.json();

        if (data.error) {
            if (data.turn_limit_reached) {
                showComplete();
            } else {
                addMessage('system', `âš ï¸ ${data.error}`);
            }
            return;
        }

        // ìŒì„± ì…ë ¥ì´ë©´ ì¸ì‹ëœ í…ìŠ¤íŠ¸ í‘œì‹œ
        if (input.type === 'audio' && data.transcribed_text) {
            // ë§ˆì§€ë§‰ player ë©”ì‹œì§€ ì—…ë°ì´íŠ¸
            const msgs = document.querySelectorAll('.msg.player');
            const lastMsg = msgs[msgs.length - 1];
            if (lastMsg) {
                lastMsg.innerHTML = `<div class="label">Tu</div>ğŸ¤ "${data.transcribed_text}"<div class="meta">Turno ${data.turn_number}</div>`;
            }
        }

        // NPC ì‘ë‹µ ì²˜ë¦¬ (PRE/DYN/Boundary ê³µí†µ)
        const npcLine = data.actor_line || data.pre_transcript || '...';
        const audioUrl = data.pre_audio_url || null;
        const ttsB64 = data.tts_audio_base64 || null;
        addNpcMessage(npcLine, audioUrl, ttsB64, data.turn_number);

        // í„´ ì—…ë°ì´íŠ¸
        turnsRemaining = data.turns_remaining;
        updateTurnCounter(data.turn_number, 8);
        lastKnownTurn = data.turn_number;  // â˜… ì¶”ê°€
        lastKnownLogCount += 2;  // â˜… ì¶”ê°€ (player + npc)

        // Exit DYN ì²˜ë¦¬ (NPC í‡´ì¥)
        if (data.is_exit) {
            const npcName = data.npc_name || document.getElementById('npcName').textContent;
            addMessage('system', `ğŸšª ${npcName} ha lasciato la conversazione.`);
            stopSyncPolling();
            document.querySelector('.input-area').style.display = 'none';
            showExitOptions();
            return;
        }    

        // Goal Achievement ì²˜ë¦¬
        if (data.goal_achieved) {
            // ìë™ ì±„ì  ìš”ì²­ (ì‘ë‹µ ì•ˆ ê¸°ë‹¤ë¦¼)
            fetch(`/api/rp/evaluate?team_id=${teamId}&scenario_id=${scenarioId}`, { method: 'POST' });
            showGoalAchieved();
            return;
        }

        // í„´ ì†Œì§„ í™•ì¸
        if (turnsRemaining <= 0) {
            showComplete();
        }

    } catch (e) {
        console.error('ì „ì†¡ ì‹¤íŒ¨:', e);
        addMessage('system', `âš ï¸ Errore: ${e.message}`);
    } finally {
        isProcessing = false;
        setInputEnabled(true);
        showLoading(false);
    }
}

// â•â•â•â•â•â•â•â•â•â•â• ë©”ì‹œì§€ ì¶”ê°€ â•â•â•â•â•â•â•â•â•â•â•
function addMessage(role, text, label) {
    const area = document.getElementById('chatArea');
    const msg = document.createElement('div');
    msg.className = `msg ${role}`;

    if (role === 'player') {
        msg.innerHTML = `<div class="label">Tu</div>${escapeHtml(text)}`;
    } else if (role === 'system') {
        msg.innerHTML = text;
    } else {
        msg.textContent = text;
    }

    area.appendChild(msg);
    area.scrollTop = area.scrollHeight;
}

function addNpcMessage(text, audioUrl, ttsBase64, turnNumber) {
    const area = document.getElementById('chatArea');
    const msg = document.createElement('div');
    msg.className = 'msg npc';

    const cleanText = cleanNpcText(text);
    const msgId = `npc-${++audioCounter}`;

    let audioHtml = '';
    if (audioUrl) {
        audioStore[msgId] = { url: audioUrl };
        audioHtml = `<button class="npc-audio-btn" onclick="playNpcAudio('${msgId}')">â–¶ Ascolta</button>`;
    } else if (ttsBase64) {
        const dataUrl = `data:audio/mp3;base64,${ttsBase64}`;
        audioStore[msgId] = { url: dataUrl };
        audioHtml = `<button class="npc-audio-btn" onclick="playNpcAudio('${msgId}')">â–¶ Ascolta</button>`;
    }

    // í…ìŠ¤íŠ¸ í† ê¸€ (audio tags ì œê±°ëœ í…ìŠ¤íŠ¸)
    const textToggleId = `${msgId}-text`;

    msg.innerHTML = `
        <div class="label">${document.getElementById('npcName').textContent}</div>
        ${audioHtml}
        <button class="npc-audio-btn" onclick="toggleNpcText('${textToggleId}')" style="margin-left:4px;">ğŸ“ Testo</button>
        <div class="npc-text-hidden" id="${textToggleId}">${escapeHtml(cleanText)}</div>
        <div class="meta">Turno ${turnNumber || ''}</div>
    `;

    area.appendChild(msg);
    area.scrollTop = area.scrollHeight;
}

// â•â•â•â•â•â•â•â•â•â•â• NPC ì˜¤ë””ì˜¤ ì¬ìƒ â•â•â•â•â•â•â•â•â•â•â•
function playNpcAudio(msgId) {
    const store = audioStore[msgId];
    if (!store) return;

    // ì¬ìƒ ì¤‘ì´ë©´ ì •ì§€
    if (store.audio && !store.audio.paused) {
        store.audio.pause();
        store.audio.currentTime = 0;
        return;
    }

    const audio = new Audio(store.url);
    store.audio = audio;
    audio.play().catch(e => console.warn('ì˜¤í† í”Œë ˆì´ ì‹¤íŒ¨:', e));
}

function toggleNpcText(id) {
    const el = document.getElementById(id);
    if (el) el.classList.toggle('visible');
}

// â•â•â•â•â•â•â•â•â•â•â• ìœ í‹¸ë¦¬í‹° â•â•â•â•â•â•â•â•â•â•â•
function cleanNpcText(text) {
    // [laughing], [warmly] ë“± audio tags ì œê±°
    return text.replace(/\[.*?\]/g, '').replace(/\s+/g, ' ').trim();
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function setInputEnabled(enabled) {
    document.getElementById('btnRecord').disabled = !enabled;
    document.getElementById('btnSendText').disabled = !enabled;
    document.getElementById('textInput').disabled = !enabled;
}

function showLoading(show) {
    const area = document.getElementById('chatArea');
    const existing = document.getElementById('typingBubble');

    if (show && !existing) {
        const bubble = document.createElement('div');
        bubble.className = 'typing-bubble';
        bubble.id = 'typingBubble';
        bubble.innerHTML = '<div class="dot"></div><div class="dot"></div><div class="dot"></div>';
        area.appendChild(bubble);
        area.scrollTop = area.scrollHeight;
    } else if (!show && existing) {
        existing.remove();
    }
}

// â•â•â•â•â•â•â•â•â•â•â• Exit í›„ ì˜µì…˜ â•â•â•â•â•â•â•â•â•â•â•
function showExitOptions() {
    const currentIdx = allScenarios.findIndex(s => s.scenario_id == currentScenarioId);
    const nextScenario = allScenarios[currentIdx + 1];

    const btnArea = document.createElement('div');
    btnArea.style.cssText = 'text-align:center; padding:16px;';

    if (nextScenario) {
        btnArea.innerHTML = `
            <button onclick="switchToNextScenario(${nextScenario.scenario_id})" 
                    style="background:#7c6ff7; color:#fff; border:none; padding:12px 28px; 
                           border-radius:8px; font-size:1em; font-weight:600; cursor:pointer;">
                â–¶ Scenario successivo: ${nextScenario.title || nextScenario.npc_name || 'Prossimo'}
            </button>`;
    } else {
        btnArea.innerHTML = `
            <button onclick="window.location.href='/roleplay-lobby'" 
                    style="background:#444; color:#ccc; border:none; padding:10px 24px; 
                           border-radius:8px; font-size:0.9em; cursor:pointer;">
                â† Torna alla lobby
            </button>`;
    }

    document.getElementById('chatArea').appendChild(btnArea);
    document.getElementById('chatArea').scrollTop = document.getElementById('chatArea').scrollHeight;
}

// â•â•â•â•â•â•â•â•â•â•â• ëª©ì  ë‹¬ì„± ì²˜ë¦¬ â•â•â•â•â•â•â•â•â•â•â•
function showGoalAchieved() {
    stopSyncPolling();
    document.querySelector('.input-area').style.display = 'none';

    addMessage('system', 'ğŸ¯ Obiettivo raggiunto! Hai completato questo scenario.');

    const currentIdx = allScenarios.findIndex(s => s.scenario_id == currentScenarioId);
    const nextScenario = allScenarios[currentIdx + 1];

    const btnArea = document.createElement('div');
    btnArea.style.cssText = 'text-align:center; padding:16px;';

    if (nextScenario) {
        btnArea.innerHTML = `
            <button onclick="switchToNextScenario(${nextScenario.scenario_id})" 
                    style="background:#7c6ff7; color:#fff; border:none; padding:12px 28px; 
                           border-radius:8px; font-size:1em; font-weight:600; cursor:pointer;">
                â–¶ Scenario successivo: ${nextScenario.title || nextScenario.npc_name || 'Prossimo'}
            </button>`;
    } else {
        btnArea.innerHTML = `
            <div style="color:#69db7c; font-weight:600; font-size:1.05em;">
                ğŸ† Tutti gli scenari completati! Ottimo lavoro!
            </div>
            <button onclick="window.location.href='/roleplay-lobby'" 
                    style="background:#444; color:#ccc; border:none; padding:10px 24px; 
                           border-radius:8px; font-size:0.9em; cursor:pointer; margin-top:12px;">
                â† Torna alla lobby
            </button>`;
    }

    document.getElementById('chatArea').appendChild(btnArea);
    document.getElementById('chatArea').scrollTop = document.getElementById('chatArea').scrollHeight;
}

// â•â•â•â•â•â•â•â•â•â•â• ë‹¤ìŒ ì‹œë‚˜ë¦¬ì˜¤ ì „í™˜ â•â•â•â•â•â•â•â•â•â•â•
async function switchToNextScenario(nextId) {
    document.getElementById('chatArea').innerHTML = '';
    document.querySelector('.input-area').style.display = '';

    currentScenarioId = nextId;
    lastKnownLogCount = 0;
    lastKnownTurn = 0;

    const sc = allScenarios.find(s => s.scenario_id == nextId);
    if (sc) {
        applyScenarioDetail(sc);
        turnsRemaining = 8 - (sc.current_turn || 0);
        updateTurnCounter(sc.current_turn || 0, 8);
    }

    await loadHistory();

    if (lastKnownLogCount === 0) {
        addMessage('system', `ğŸ’¡ Nuovo scenario iniziato! Parla con ${sc?.npc_name || 'NPC'}.`);
    }

    startSyncPolling();
}

function showComplete() {
    stopSyncPolling();
    document.querySelector('.input-area').style.display = 'none';
    addMessage('system', 'ğŸ‰ Conversazione completata! Hai usato tutti i turni disponibili.<br>Non Ã¨ possibile continuare la conversazione.');
}

async function exitPlay() {
    // íŒ€ì—ì„œ ìë™ íƒˆí‡´
    try {
        await fetch('/api/rp-student/leave-team', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ session_id: sessionId })
        });
    } catch (e) { console.error('í‡´ì¥ ì˜¤ë¥˜:', e); }
    window.location.href = `/roleplay-lobby?class_name=${urlParams.get('class_name') || ''}`;
}
</script>
</body>
</html>